## GET 和 POST 的区别有哪些？


## 谈谈你对 TCP 三次握手和四次挥手的理解

tcp 将 http 长报文划分为短报文（tcp 通常将数据分成长度为 MSS 的若干段），通过三次握手与服务端建立连接，进行可靠传输

> MSS（Maxitum Segment Size）最大分段大小的缩写，MSS 就是 tcp 数据包每次能够传输的最大数据分段， 通讯双方会根据双方提供的 MSS 值的最小值确定为这次连接的最大 MSS 值。

**三次握手**

![](https://upload-images.jianshu.io/upload_images/9658881-14388ff91eda35c6.png?imageMogr2/auto-orient/strip|imageView2/2/w/855/format/webp)

三次握手(Three-way Handshake)，是指建立一个 TCP 连接时，需要客户端和服务器总共发送 3 个包。

1. **第一次握手([SYN], Seq = x)**

客户端发送一个 SYN 标记的包，Seq 初始序列号 x，发送完成后客户端进入`SYN_SEND`状态。

2. **第二次握手([SYN,ACK], Seq = y, ACK = x + 1)**

服务器返回确认包(ACK)应答，同时还要发送一个 SYN 包回去。ACK = x + 1,表示确认收到(客户端发来的 Seq 值 + 1)，Seq = y, 表示让客户端确认是否能收到。发送完成后`服务端`进入`SYN_RCVD（received 缩写，收到）`状态。

3. **第三次握手([ACK], ACK = y + 1)**

客户端再次发送确认包(ACK),ACK = y + 1, 表示确认收到服务器的包（服务端发来的 Seq 值 + 1）。`客户端`发送完毕后，进入`ESTABLISHED（建立了）`状态，`服务端`接收到这个包，也进入`ESTABLISHED`状态, TCP 握手结束。

> 换一种抽象派的方式解释：
>
> （1）客户端：hello，你是 server 么？
>
> （2）服务端：hello，我是 server，你是 client 么?
>
> （3）客户端：yes，我是 client

**四次挥手**

建立连接成功后，接下来就正式传输数据

然后，待到断开连接时，需要进行四次挥手（因为是全双工的，所以需要四次挥手）

![](https://upload-images.jianshu.io/upload_images/9658881-bee754e3da92d278.png?imageMogr2/auto-orient/strip|imageView2/2/w/835/format/webp)

TCP 连接的断开需要发送四个包，所以称为四次挥手。

1. 第一次挥手（[FIN], Seq = x）

客户端发送一个 FIN 标记的包，告诉服务器需要关闭连接，表示自己不用发送数据了，但是还可以接收数据。发送完成后，`客户端`进入 `FIN_WAIT_1` 状态。

2. 第二次挥手 ([ACK], ACK = x + 1)

服务端发送一个 ACK 的确认包，告诉客户端接收到关闭的请求，但是还没有准备好。发送完成后，`服务端`进入 `CLOSE_WAIT` 状态，`客户端`收到这个包后，进入 `FIN_WAIT_2`，等待服务器关闭连接。

3. 第三次挥手 ([FIN], Seq = y)

服务端准备好关闭连接时，发送 FIN 标记的包，告诉客户端准备关闭了。发送完成后，`服务端`进入 `LAST_ACK` 状态，等待客户端确认。

4. 第四次挥手 ([ACK], ACK = y + 1)

客户端接收到服务端的关闭请求，再发送 ACK 标记的确认包，进入 `TIME_WAIT` 状态，等待服务端可能请求重传的 ACK 包。

服务端接收到 ACK 包后，关闭连接，进入 `CLOSED` 状态。

客户端在`等待固定时间(两个最大段生命周期)后，没有接收到服务的 ACK 包`，认为服务器已关闭连接，自己也关闭连接，进入 `CLOSED` 状态。

> 同样换一种抽象派的方式解释：
>
> （1）主动方：我已经关闭了向你那边的主动通道了，只能被动接收了
>
> （2）被动方：收到通道关闭的信息
>
> （3）被动方：那我也告诉你，我这边向你的主动通道也关闭了
>
> （3）主动方：最后收到数据，之后双方无法通信

**为什么要"三次握手，四次挥手"**

1. 三次握手

换个易于理解的视角来看为什么要 3 次握手。

客户端和服务端通信前要进行连接，“3 次握手”的作用就是`双方都能明确自己和对方的收、发能力是正常的`。

`第一次握手`：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。

`第二次握手`：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。 从客户端的视角来看，我接到了服务端发送过来的响应数据包，说明服务端接收到了我在第一次握手时发送的网络包，并且成功发送了响应数据包，这就说明，服务端的接收、发送能力正常。而另一方面，我收到了服务端的响应数据包，说明我第一次发送的网络包成功到达服务端，这样，我自己的发送和接收能力也是正常的。

`第三次握手`：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力，服务端的发送、接收能力是正常的。 第一、二次握手后，服务端并不知道客户端的接收能力以及自己的发送能力是否正常。而在第三次握手时，服务端收到了客户端对第二次握手作的回应。从服务端的角度，我在第二次握手时的响应数据发送出去了，客户端接收到了。所以，我的发送能力是正常的。而客户端的接收能力也是正常的。

经历了上面的三次握手过程，客户端和服务端都确认了自己的接收、发送能力是正常的。之后就可以正常通信了。

每次都是接收到数据包的一方可以得到一些结论，发送的一方其实没有任何头绪。我虽然有发包的动作，但是我怎么知道我有没有发出去，而对方有没有接收到呢？

而从上面的过程可以看到，最少是需要三次握手过程的。两次达不到让双方都得出自己、对方的接收、发送能力都正常的结论。其实每次收到网络包的一方至少是可以得到：对方的发送、我方的接收是正常的。而每一步都是有关联的，下一次的“响应”是由于第一次的“请求”触发，因此每次握手其实是可以得到额外的结论的。比如第三次握手时，服务端收到数据包，表明看服务端只能得到客户端的发送能力、服务端的接收能力是正常的，但是结合第二次，说明服务端在第二次发送的响应包，客户端接收到了，并且作出了响应，从而得到额外的结论：客户端的接收、服务端的发送是正常的。

2. 四次挥手

TCP 连接是双向传输的对等的模式，就是说双方都可以同时向对方发送或接收数据。当有一方要关闭连接时，会发送指令告知对方，我要关闭连接了。这时对方会回一个 ACK，此时一个方向的连接关闭。但是另一个方向仍然可以继续传输数据，等到发送完了所有的数据后，会发送一个 FIN 段来关闭此方向上的连接。接收方发送 ACK 确认关闭连接。注意，接收到 FIN 报文的一方只能回复一个 ACK, 它是无法马上返回对方一个 FIN 报文段的，因为结束数据传输的“指令”是上层应用层给出的，我只是一个“搬运工”，我无法了解“上层的意志”。

参考链接

- https://zhuanlan.zhihu.com/p/53374516
- https://www.jianshu.com/p/12790cea57ac

## HTTP 缓存有哪些方案？

两种方案区别如下：

## 长连接与短连接

首先看`tcp/ip`层面的定义：

- 长连接：一个 tcp/ip 连接上可以连续发送多个数据包，在 tcp 连接保持期间，如果没有数据包发送，需要双方发检测包以维持此连接，一般需要自己做在线维持（类似于心跳包）
- 短连接：通信双方有数据交互时，就建立一个 tcp 连接，数据发送完成后，则断开此 tcp 连接 （连接 -> 传输数据 -> 断开连接）

然后在 http 层面：

- `http1.0`中，默认使用的是短连接，也就是说，浏览器每进行一次 http 操作，就建立一次连接，任务结束就中断连接，譬如每一个静态资源请求时都是一个单独的连接，
  - 无法复用链接，完成即断开，重新慢启动和 TCP 3 次握手
  - head of line blocking: 线头阻塞，导致请求之间互相影响
- `http1.1` 起，默认使用长连接，使用长连接会有这一行`Connection: keep-alive`，在长连接的情况下，当一个网页打开完成后，客户端和服务端之间用于传输 http 的 tcp 连接不会关闭，如果客户端再次访问这个服务器的页面，会继续使用这一条已经建立的连接
  - host 字段指定对应的虚拟站点
  - 新增功能:
    - 断点续传
    - 身份认证
    - 状态管理
    - cache 缓存
      - Cache-Control
      - Expires
      - Last-Modified
      - Etag

注意： **keep-alive 不会永远保持，它有一个持续时间，一般在服务器中配置（如 apache），另外长连接需要客户端和服务器都支持时才有效**

## http 2.0

http 2.0 不是 https，它相当于是 http 的下一代规范（譬如 https 的请求可以是 http2.0 规范的）

然后简述下 http2.0 与 http1.1 的显著不同点：

- http 2.0 把所有请求和响应的消息采用二进制格式封装而非 http1.1 的纯文本格式，显著提高传输灵活性
- http 1.1 支持长连接和请求的流水线（Pipeling 管道）处理，在一个 tcp 连接上可以传送多个 http 请求和响应，减少了建立和关闭连接的消耗和延迟。
- http 2.0 中，一个 tcp/ip 请求可以请求多个资源，也就是说，只要一次 tcp/ip 请求，就可以请求若干个资源，分割成更小的帧请求，速度明显提升。
- http 2.0 使用报头压缩，降低开销
- http 2.0 让服务器可以将响应主动推送给客户端

> 队头阻塞（Head of line blocking） 由于 tcp/ip 本身有并发数限制 （浏览器限制了同一个域名下的请求数量，Chrome 下一般是限制六个连接），当页面中需要请求很多资源的时候，队头阻塞（Head of line blocking）会导致在达到最大请求数量时，剩余的资源需要等待其他资源请求完成后才能发起请求。

所以，如果 http 2.0 全面应用，很多 http1.1 中的优化方案就无需用到了（譬如打包成精灵图，静态资源多域名拆分等）

然后简述下 http 2.0 的一些特性：

- 多路复用（即一个 tcp/ip 连接可以请求多个资源）
- 首部压缩（http header 编码压缩，减少体积）
- 二进制分帧（在应用层跟传送层之间增加了一个二进制分帧层，改进传输性能，实现低延迟和高吞吐量）
- 服务器端推送（服务端可以对客户端的一个请求发出多个响应，可以主动通知客户端）
- 请求优先级（如果流被赋予了优先级，它就会基于这个优先级来处理，由服务器对请求的响应设置优先级权重，决定需要多少资源来处理该请求。）

扩展链接

- [关于队头阻塞（Head-of-Line blocking），看这一篇就足够了](https://zhuanlan.zhihu.com/p/330300133)

## 简单讲解一下 http2 的多路复用

HTTP2 采用二进制格式传输，取代了 HTTP1.x 的文本格式，二进制格式解析更高效。多路复用代替了 HTTP1.x 的序列和阻塞机制，所有的相同域名请求都通过同一个 TCP 连接并发完成。在 HTTP1.x 中，并发多个请求需要多个 TCP 连接，浏览器为了控制资源会有 6-8 个 TCP 连接都限制。

HTTP2 中同域名下所有通信都在单个连接上完成，消除了因多个 TCP 连接而带来的延时和内存消耗。单个连接上可以并行交错的请求和响应，之间互不干扰

## websocket

TODO:

## HTTP 和 HTTPS 的区别有哪些？

HTTPS = HTTP + SSL/TLS（安全层）

区别列表

- 1.HTTP 是明文传输的，不安全；HTTPS 是加密传输的，非常安全。
- 2.HTTP 使用 80 端口，HTTPS 使用 443 端口。
- 3.HTTP 较快，HTTPS 较慢。
- 4.HTTPS 的证书一般需要购买（但也有免费的），HTTP 不需要证书。

了解更多

- [图解SSL/TLS协议-阮一峰](https://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html)
- [HTTPS原理以及握手阶段](https://juejin.cn/post/6844903892765900814)

## 介绍 HTTPS 握手过程

1.客户端提交 https 请求

2.服务器响应客户,并把服务器公钥发给客户端

3.客户端验证公钥的有效性

4.有效后，客户端会生成一个会话密钥(一个随机数)

5.用服务器公钥加密这个会话密钥后，发送给服务器

6.服务器收到公钥加密的密钥后，用私钥解密，获取会话密钥

7.客户端与服务器利用会话密钥对传输数据进行对称加密通信

![](https://pic2.zhimg.com/80/v2-b9ad0001226531da127600957c1432a5_720w.jpg)

参考文章

- https://zhuanlan.zhihu.com/p/240389098

## HTTPS 握手过程中，客户端如何验证证书的合法性

1.校验证书的颁发机构是否受客户端信任。

2.通过 CRL 或 OCSP 的方式校验证书是否被吊销。

3.对比系统时间，校验证书是否在有效期内。

4.通过校验对方是否存在证书的私钥，判断证书的网站域名是否与证书颁发的域名一致。

## 介绍下前端加密的常见场景和方法

首先，加密的目的，简而言之就是将明文转换为密文、甚至转换为其他的东西，用来隐藏明文内容本身，防止其他人直接获取到敏感明文信息、或者提高其他人获取到明文信息的难度。通常我们提到加密会想到密码加密、HTTPS 等关键词，这里从场景和方法分别提一些我的个人见解。

**场景-密码加密**

前端密码传输过程中如果不加密，在日志中就可以拿到用户的明文密码，对用户安全不太负责。这种加密其实相对比较简单，可以使用 PlanA-前端加密、后端解密后计算密码字符串的 MD5/MD6 存入数据库；也可以 PlanB-直接前端使用一种稳定算法加密成唯一值、后端直接将加密结果进行 MD5/MD6，全程密码明文不出现在程序中。PlanA 使用 Base64/Unicode+1 等方式加密成非明文，后端解开之后再存它的 MD5/MD6。PlanB 直接使用 MD5/MD6 之类的方式取 Hash，让后端存 Hash 的 Hash。

**场景-数据包加密**

应该大家有遇到过：打开一个正经网站，网站底下蹦出个不正经广告——比如 X 通的流量浮层，X 信的插入式广告......（我没有针对谁）但是这几年，我们会发现这种广告逐渐变少了，其原因就是大家都开始采用 HTTPS 了。被人插入这种广告的方法其实很好理解：你的网页数据包被抓取->在数据包到达你手机之前被篡改->你得到了带网页广告的数据包->渲染到你手机屏幕。而 HTTPS 进行了包加密，就解决了这个问题。严格来说我认为从手段上来看，它不算是一种前端加密场景；但是从解决问题的角度来看，这确实是前端需要知道的事情。Plan 全面采用 HTTPS

**场景-展示成果加密**

经常有人开发网页爬虫爬取大家辛辛苦苦一点一点发布的数据成果，有些会影响你的竞争力，有些会降低你的知名度，甚至有些出于恶意爬取你的公开数据后进行全量公开......比如有些食谱网站被爬掉所有食谱，站点被克隆；有些求职网站被爬掉所有职位，被拿去卖信息；甚至有些小说漫画网站赖以生存的内容也很容易被爬取。Plan 将文本内容进行展示层加密，利用字体的引用特点，把拿给爬虫的数据变成“乱码”。举个栗子：正常来讲，当我们拥有一串数字“12345”并将其放在网站页面上的时候，其实网站页面上显示的并不是简单的数字，而是数字对应的字体的“12345”。这时我们打乱一下字体中图形和字码的对应关系，比如我们搞成这样：图形：12345 字码：23154 这时，如果你想让用户看到“12345”，你在页面中渲染的数字就应该是“23154”。这种手段也可以算作一种加密。
